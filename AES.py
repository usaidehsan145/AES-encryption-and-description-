# -*- coding: utf-8 -*-
"""Information_Security(A1)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1arCjl2QLBMHkcWwOmXclXypkArglohME
"""

import numpy as np
import pandas as pd
from google.colab import files
import io
import binascii

# Define the Substitution Table
substitution_table = {
    "0000": "1010", "0001": "0000", "0010": "1001", "0011": "1110",
    "0100": "0110", "0101": "0011", "0110": "1111", "0111": "0101",
    "1000": "0001", "1001": "1101", "1010": "1100", "1011": "0111",
    "1100": "1011", "1101": "0100", "1110": "0010", "1111": "1000"
}

inverse_substitution_table = {
    "0000": "0001", "0001": "1000", "0010": "1110", "0011": "0101",
    "0100": "1101", "0101": "0111", "0110": "0100", "0111": "1011",
    "1000": "1111", "1001": "0010", "1010": "0000", "1011": "1100",
    "1100": "1010", "1101": "1001", "1110": "0011", "1111": "0110"
}

# Function to perform SubNibbles operation
def perform_subnibbles(input_block):

    output_block = ""
    for nibble in [input_block[i:i+4] for i in range(0, len(input_block), 4)]:
        if nibble in substitution_table:
            output_block += substitution_table[nibble]
    return output_block

# Function to perform Inverse SubNibbles operation
def perform_inverse_subnibbles(input_block):
    output_block = ""
    for nibble in [input_block[i:i+4] for i in range(0, len(input_block), 4)]:
        if nibble in inverse_substitution_table:
            output_block += inverse_substitution_table[nibble]
    return output_block

# Function to perform ShiftRows operation on 16-bit hexadecimal input
def shift_rows(input_hex):
    # Ensure the input is 16-bit hexadecimal
    input_hex = input_hex.zfill(4)

    # Extract individual digits
    digit0, digit1, digit2, digit3 = [input_hex[i:i+1] for i in range(0, len(input_hex), 1)]

    # Shuffle the 0th and 2nd indexes
    output_hex = digit2 + digit1 + digit0 + digit3

    return output_hex

# Function to perform multiplication in the finite field GF(2^4)
def gf_multiply(a, b):
    m = 0
    while b > 0:
        if b & 1:
            m ^= a
        a <<= 1
        if a & 0x10:
            a ^= 0x13
        b >>= 1
    return m

# Function to perform MixColumns operation
def mix_columns(input_block):
    output_block = [0, 0, 0, 0]

    # Define the MixColumns constant matrix
    matrix = [[1, 4], [4, 1]]

    for col in range(2):
        for row in range(2):
            result = 0
            for i in range(2):
                result ^= gf_multiply(matrix[row][i], input_block[col * 2 + i])
            output_block[col * 2 + row] = result

    return output_block

# Function to perform Inverse MixColumns operation
def Inverse_mix_columns(input_block):
    output_block = [0, 0, 0, 0]

    # Define the Inverse MixColumns constant matrix
    matrix = [[9, 2], [2, 9]]

    for col in range(2):
        for row in range(2):
            result = 0
            for i in range(2):
                result ^= gf_multiply(matrix[row][i], input_block[col * 2 + i])
            output_block[col * 2 + row] = result

    return output_block

# Function to generate round keys from a 16-bit master key
def generate_round_keys(master_key):
    round_keys = []

    # Initialize the round constants
    rcon1 = "1110"
    rcon2 = "1010"

    # Convert the master key to binary
    master_key_binary = ''.join(format(int(c, 16), '04b') for c in master_key)

    # Extract individual nibbles from the master key
    w0, w1, w2, w3 = [master_key_binary[i:i+4] for i in range(0, len(master_key_binary), 4)]

    # Calculate w4 to w7
    w4 = ''.join(format(int(w0[i], 2) ^ int(perform_subnibbles(w3)[i], 2) ^ int(rcon1[i], 2), '01b') for i in range(4))
    w5 = ''.join(format(int(w1[i], 2) ^ int(w4[i], 2), '01b') for i in range(4))
    w6 = ''.join(format(int(w2[i], 2) ^ int(w5[i], 2), '01b') for i in range(4))
    w7 = ''.join(format(int(w3[i], 2) ^ int(w6[i], 2), '01b') for i in range(4))

    round_keys.extend([w4, w5, w6, w7])

    # Calculate w8 to w11
    w8 = ''.join(format(int(w4[i], 2) ^ int(perform_subnibbles(w7)[i], 2) ^ int(rcon2[i], 2), '01b') for i in range(4))
    w9 = ''.join(format(int(w5[i], 2) ^ int(w8[i], 2), '01b') for i in range(4))
    w10 = ''.join(format(int(w6[i], 2) ^ int(w9[i], 2), '01b') for i in range(4))
    w11 = ''.join(format(int(w7[i], 2) ^ int(w10[i], 2), '01b') for i in range(4))

    round_keys.extend([w8, w9, w10, w11])

    k1 = round_keys[:4]
    k1 = format(int(''.join(k1), 2), '04X')

    k2 = round_keys[4:]
    k2 = format(int(''.join(k2), 2), '04X')

    return k1, k2

def add_round_key(block, round_key):

  result = ''
  for i in range(4):
    val = str(hex(int(block[i],16) ^ int(round_key[i],16))[2:])
    result = result+val

  return result

# Function to get valid 16-bit hexadecimal input
def get_valid_hex_input(prompt):
    while True:
        user_input = input()
        user_input = user_input.replace(" ", "").upper()
        if all(c in "0123456789ABCDEF" for c in user_input):
            user_input = user_input.zfill(4)
            user_input = user_input[:4]
            return user_input
        else:
            print("Invalid input. Please enter a valid hexadecimal number (up to 4 digits).")

def encryption():

  # Get a valid 16-bit hexadecimal input from the user
  print("Enter a text block: ")
  text_block = get_valid_hex_input("")

  # Convert the hexadecimal input to binary
  binary_input = ''.join(format(int(c, 16), '04b') for c in text_block)
  # Perform the SubNibbles operation
  subnibbles = perform_subnibbles(binary_input)
  hex_subnibbles = ''.join(format(int(subnibbles[i:i+4], 2), 'X') for i in range(0, len(subnibbles), 4))
  print(f"SubNibbles ({text_block}): ", hex_subnibbles)

  # Perform the ShiftRows operation on the hexadecimal input
  shifted_rows = shift_rows(text_block)
  print(f"ShiftRow ({text_block}):", shifted_rows)

  input_block = [int(text_block[i:i+1], 16) for i in range(4)]
  # Perform the MixColumns operation on the input
  output_block = mix_columns(input_block)
  mix_col = ''.join(format(x, 'X') for x in output_block)
  print(f"MixColumns ({text_block}):", mix_col)

  # Get a valid 16-bit hexadecimal input from the user
  print("Enter a key: ")
  hex_input = get_valid_hex_input("")
  round_key = generate_round_keys(hex_input)
  print(f"GenerateRoundKeys({hex_input}) = {round_key}")

def decryption():

  print("Enter the cypher text block: ")
  cyphertext = get_valid_hex_input("")

  print("Enter the key: ")
  key = get_valid_hex_input("")

  round_key1,round_key2 = generate_round_keys(key)

  s1 = shift_rows(cyphertext)
  s2 = add_round_key(s1,round_key2)
  binary_s2 = ''.join(format(int(c, 16), '04b') for c in s2)
  s3 = perform_inverse_subnibbles(binary_s2)
  s3 = ''.join(format(int(s3[i:i+4], 2), 'X') for i in range(0, len(s3), 4))
  s4 = shift_rows(s3)
  s4_block = [int(s4[i:i+1], 16) for i in range(4)]
  s5 = Inverse_mix_columns(s4_block)
  s5 = ''.join(format(x, 'X') for x in s5)
  s6 = add_round_key(s5, round_key1)
  binary_s6 = ''.join(format(int(c, 16), '04b') for c in s6)
  s7 = perform_inverse_subnibbles(binary_s6)
  s7= ''.join(format(int(s7[i:i+4], 2), 'X') for i in range(0, len(s7), 4))

  print("decrypted block: ", s7)

def decrypt_secret_file():

  decrypted_content = []
  file_name = 'secret.txt'

  print("Reading encrypted file secret.txt...")
  # Open and read the uploaded file
  with open(file_name, 'r') as file:
    file_contents = file.read()

  file_contents = file_contents.split()

  print("Enter the decryption key: ")
  key = get_valid_hex_input("")

  round_key1,round_key2 = generate_round_keys(key)

  for cyphertext in file_contents:
    s1 = shift_rows(cyphertext)
    s2 = add_round_key(s1,round_key2)
    binary_s2 = ''.join(format(int(c, 16), '04b') for c in s2)
    s3 = perform_inverse_subnibbles(binary_s2)
    s3 = ''.join(format(int(s3[i:i+4], 2), 'X') for i in range(0, len(s3), 4))
    s4 = shift_rows(s3)
    s4_block = [int(s4[i:i+1], 16) for i in range(4)]
    s5 = Inverse_mix_columns(s4_block)
    s5 = ''.join(format(x, 'X') for x in s5)
    s6 = add_round_key(s5, round_key1)
    binary_s6 = ''.join(format(int(c, 16), '04b') for c in s6)
    s7 = perform_inverse_subnibbles(binary_s6)
    s7= ''.join(format(int(s7[i:i+4], 2), 'X') for i in range(0, len(s7), 4))
    decrypted_content.append(s7)

  plain_text = ' '.join(decrypted_content)
  ascii_decrypted_text = ''.join([binascii.unhexlify(hex_value).decode('utf-8') for hex_value in decrypted_content])
  ascii_decrypted_text = ascii_decrypted_text.rstrip('\0')

  print("\n\nDecrypted Result\n---------------------------------------------------------")
  print(ascii_decrypted_text)
  print("---------------------------------------------------------")

  file_path = "plain.txt"

  with open(file_path, 'a') as file:

    file.write('Decrypted blocks:\n')
    for item in decrypted_content:
        file.write(str(item) + ' ')
    file.write('\nDecrypted Result: \n')

    file.write(ascii_decrypted_text + '\n')

encryption()

decryption()

decrypt_secret_file()

